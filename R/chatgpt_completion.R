#' explain_data
#'
#' This function generates an explanation of a specific subject for a specific audience, given the underlying dataset.
#'
#' @param data A data frame containing the data set to be explained.
#' @param subject A character string specifying the subject of the explanation.
#' @param audience A character string specifying the intended audience for the explanation (default is "a faculty board").
#' @param user_message_template A character string template for the user's message to the chatbot. The template can contain placeholders {subject} and {audience} to be filled with the actual values. The default template includes a placeholder for {table}, which will be replaced with a formatted table of the data set.
#' @param system_message_template A character string template for the system's message to the chatbot. This message provides guidance to the model in generating the explanation. The default message is probably fine for most cases.
#' @param token An optional authentication token for the chatgpt_chat_completion function (default is NULL).
#' @param model A character string specifying the GPT model to be used for chatbot completion (default is "gpt-4").
#' @return This function returns the response generated by the chatgpt_chat_completion function.
#'
#' @examples
#' # Generate an explanation for a faculty board
#' explain_data(
#'   data = mtcars,
#'   subject = "Figure 1: engine performance and properties of various cars.",
#'   audience = "a faculty board")
#'
#' # Generate an explanation for a different audience
#' explain_data(
#'   data = mtcars,
#'   subject = "Figure 1: engine performance and properties of various cars.",
#'   audience = "a group of toddlers")
#' @importFrom stringr str_flatten
#' @importFrom knitr kable
#' @importFrom glue glue
#' @importFrom magrittr %>%
#' @export
explain_data <- function(data,
                         subject,
                         audience = "a faculty board",
                         user_message_template = c("Describe {subject} for {audience}.\n\n{table}") %>%
                           stringr::str_flatten(" "),
                         system_message_template = c(
                           "You are a data scientist providing context and",
                           "insight on various data visualizations.",
                           "Your responses should be concise and to the point,",
                           "and targeted at the requested audience.",
                           "You should highlight common patterns,",
                           "interactions between variables,",
                           "and point out discrepancies in the data.",
                           "You are allowed to use basic markdown markup,",
                           "but should not add headers, lists, etc."
                         ) %>% stringr::str_flatten(" "),
                         token = NULL,
                         model = "gpt-4") {

  table <- knitr::kable(data) %>% stringr::str_flatten("\n")
  system_message = glue::glue(system_message_template)
  user_message = glue::glue(user_message_template)

  chatgpt_chat_completion(list(list(role = "system", content = system_message), list(role = "user", content = user_message)), model, token)
}

#' Generate completion with OpenAI
#'
#' This function sends a request to the OpenAI API to generate a completion for a given prompt.
#'
#' @param prompt The text prompt to generate completion for.
#' @param model The model to use for completion. Defaults to "gpt-3.5-turbo".
#' @param token An optional API key. If not provided, the function will attempt to retrieve the key from the environment variable "OPENAI_API_KEY".
#' @return The generated completion text.
#' @import httr2
#' @import jsonlite
#' @importFrom magrittr %>%
#' @importFrom glue glue
#' @export
#' @examples
#' # note; currently returns 404?
#' # chatgpt_completion("Once upon a time")
chatgpt_completion <- function(prompt, model = "gpt-3.5-turbo", token = NULL) {
  if (is.null(token)) {
    token <- Sys.getenv("OPENAI_API_KEY")
  }

  auth_header = glue::glue("Bearer {token}")

  req <-
    httr2::request("https://api.openai.com/v1/completions") %>%
    httr2::req_headers(Authorization = auth_header) %>%
    httr2::req_body_json(list(model = model, prompt = prompt))

  res <- httr2::req_perform(req)
  body <- httr2::resp_body_json(res)
  return(body$choices[[1]]$content)
}

#' Generate chat completion using OpenAI GPT large language models
#'
#' This function generates a chat completion using OpenAI large language models.
#'
#' @param messages A character vector or list of messages exchanged in the chat. Each message should be a list containing 'role' and 'content' keys. The 'role' can be 'system', 'user', or 'assistant'. The 'content' contains the text of the message.
#' @param model The model to be used for chat generation. Defaults to "gpt-3.5-turbo".
#' @param token Your OpenAI API key. If not provided, the function will attempt to retrieve it from the environment variable OPENAI_API_KEY.
#' @return The generated completion text.
#' @import httr2
#' @import jsonlite
#' @importFrom magrittr %>%
#' @importFrom glue glue
#' @importFrom purrr is_character
#' @export
#' @examples
#' chatgpt_chat_completion("What is the meaning of life?")
chatgpt_chat_completion <- function (messages, model = "gpt-3.5-turbo", token = NULL){
  if (is.null(token)) {
    token <- Sys.getenv("OPENAI_API_KEY")
  }

  if (purrr::is_character(messages)) {
    messages <- list(
      list(role = "system", content = "You are a helpful data scientist. You provide truthful and concise answers. When asked for an opinion, you will provide one based on the balance of probabilities as you see them."),
      list(role = "user", content = messages)
    )
  }

  auth_header = glue::glue("Bearer {token}")

  req <-
    httr2::request("https://api.openai.com/v1/chat/completions") %>%
    httr2::req_headers(Authorization = auth_header) %>%
    httr2::req_body_json(list(model = model,
                              messages = messages))

  res <- httr2::req_perform(req)
  body <- httr2::resp_body_json(res)

  return(body$choices[[1]]$message$content)
}

